#include <vector>
#include <iostream>
#include <map>
#include <memory>
#include "CFGBuilder.h"
#include "../tokenizer/SourceLexer.h"

using namespace std;

map<Procedure, shared_ptr<ControlFlowNode>> CFGBuilder::GenerateCFG(string& source_filename) {
	SourceLexer lexer = SourceLexer(source_filename);
	vector<SourceToken> tokens = lexer.GetAllTokens();
	map<Procedure, shared_ptr<ControlFlowNode>> roots;
	int token_idx = 0;
	int line_idx = 1;
	while (token_idx < (int)tokens.size()) {
		pair<Procedure, shared_ptr<ControlFlowNode>> res = GenerateProcedureCFG(tokens, token_idx, line_idx);
		roots.insert(res);
	}
	return roots;
}

pair<Procedure, shared_ptr<ControlFlowNode>> CFGBuilder::GenerateProcedureCFG(vector<SourceToken> tokens, int& token_idx, int& line_idx) {
	// procedure xx {
	shared_ptr<ControlFlowNode> root (new ControlFlowNode());
	shared_ptr<ControlFlowNode> prev_end = root;
	Procedure proc = tokens.at(token_idx + 1).GetStringVal();
	token_idx += 3;
	while (tokens.at(token_idx).GetType() != SourceTokenType::kRightCurly) {
		// pair<shared_ptr<ControlFlowNode>, shared_ptr<ControlFlowNode>> result = GenerateStatementCFG(tokens, token_idx, line_idx, root);
		shared_ptr<ControlFlowNode> new_end = GenerateStatementCFG(tokens, token_idx, line_idx, prev_end);
		prev_end = new_end;
	}
	token_idx += 1;
	return pair(proc, root);
}

shared_ptr<ControlFlowNode> CFGBuilder::GenerateStatementCFG(vector<SourceToken> tokens, int& token_idx, int& line_idx, shared_ptr<ControlFlowNode> prev_end) {
	if (tokens.at(token_idx + 1).GetType() == SourceTokenType::kEqual || tokens.at(token_idx).IsRead() || tokens.at(token_idx).IsCall() || tokens.at(token_idx).IsPrint()) {
		return GenerateSimpleCFG(tokens, token_idx, line_idx, prev_end);
	}
	else if (tokens.at(token_idx).IsWhile()) {
		return GenerateWhileCFG(tokens, token_idx, line_idx, prev_end);
	}
	else {
		// if-else
		return GenerateIfCFG(tokens, token_idx, line_idx, prev_end);
	}
}


shared_ptr<ControlFlowNode> CFGBuilder::GenerateSimpleCFG(vector<SourceToken> tokens, int& token_idx, int& line_idx, shared_ptr<ControlFlowNode> prev_end) {
	if (prev_end->isEmpty()) {
		mapping.insert(pair(line_idx, prev_end));
	}
	prev_end->AddStmtNum(line_idx);
	line_idx += 1;
	while (tokens.at(token_idx).GetType() != SourceTokenType::kSemiColon) {
		token_idx += 1;
	}
	token_idx += 1;
	return prev_end;
}

shared_ptr<ControlFlowNode> CFGBuilder::GenerateWhileCFG(vector<SourceToken> tokens, int& token_idx, int& line_idx, shared_ptr<ControlFlowNode> prev_end) {
	shared_ptr<ControlFlowNode>* head_ptr;
	if (prev_end->isEmpty()) {
		// prev_end is empty node generated by prev while/if, can directly use
		head_ptr = &prev_end;
		mapping.insert(pair(line_idx, prev_end));
		prev_end->AddStmtNum(line_idx);
	}
	else {
		cout << "new while cond" << endl;
		shared_ptr<ControlFlowNode> cond(new ControlFlowNode());
		prev_end->AddOutgoingNode(cond);
		cond->AddStmtNum(line_idx);
		head_ptr = &cond;
	}
	line_idx += 1;
	while (tokens.at(token_idx).GetType() != SourceTokenType::kLeftCurly) {
		token_idx += 1;
	}
	token_idx += 1;
	shared_ptr<ControlFlowNode> body_start_node(new ControlFlowNode());
	shared_ptr<ControlFlowNode> body_end_node;
	(*head_ptr)->AddOutgoingNode(body_start_node);
	while (tokens.at(token_idx).GetType() != SourceTokenType::kRightCurly) {
		body_end_node = GenerateStatementCFG(tokens, token_idx, line_idx, body_start_node);
		body_start_node = body_end_node;
	}
	body_start_node->AddOutgoingNode(*head_ptr);
	shared_ptr<ControlFlowNode> dummy_node(new ControlFlowNode());
	(*head_ptr)->AddOutgoingNode(dummy_node);
	token_idx += 1;
	return dummy_node;
}

shared_ptr<ControlFlowNode> CFGBuilder::GenerateIfCFG(vector<SourceToken> tokens, int& token_idx, int& line_idx, shared_ptr<ControlFlowNode> prev_end) {
	shared_ptr<ControlFlowNode>* head_ptr;
	if (prev_end->isEmpty()) {
		// prev_end is empty node generated by prev while/if, can directly use as cond node
		head_ptr = &prev_end;
		mapping.insert(pair(line_idx, prev_end));
		prev_end->AddStmtNum(line_idx);
	}
	else {
		shared_ptr<ControlFlowNode> cond(new ControlFlowNode());
		prev_end->AddOutgoingNode(cond);
		cond->AddStmtNum(line_idx);
		head_ptr = &cond;
	}
	line_idx += 1;
	while (tokens.at(token_idx).GetType() != SourceTokenType::kLeftCurly) {
		token_idx += 1;
	}
	token_idx += 1;
	shared_ptr<ControlFlowNode> if_start_node(new ControlFlowNode());
	shared_ptr<ControlFlowNode> if_end_node;
	(*head_ptr)->AddOutgoingNode(if_start_node);
	while (tokens.at(token_idx).GetType() != SourceTokenType::kRightCurly) {
		if_end_node = GenerateStatementCFG(tokens, token_idx, line_idx, if_start_node);
		if_start_node = if_end_node;
	}
	shared_ptr<ControlFlowNode> dummy_node(new ControlFlowNode());
	if_start_node->AddOutgoingNode(dummy_node);
    // } else {
	token_idx += 3;
	shared_ptr<ControlFlowNode> else_start_node(new ControlFlowNode());
	shared_ptr<ControlFlowNode> else_end_node;
	(*head_ptr)->AddOutgoingNode(else_start_node);
	while (tokens.at(token_idx).GetType() != SourceTokenType::kRightCurly) {
		else_end_node = GenerateStatementCFG(tokens, token_idx, line_idx, else_start_node);
		else_start_node = else_end_node;
	}
	else_start_node->AddOutgoingNode(dummy_node);
	token_idx += 1;
	return dummy_node;
}

void CFGBuilder::Display(shared_ptr<ControlFlowNode> node, set<set<StmtNum>>& visited) {
	set<StmtNum> nums = node->GetElements();
	if (visited.find(nums) == visited.end() || nums.size() == 0) {
		visited.insert(nums);
		set<shared_ptr<ControlFlowNode>> nodes = node->GetOutgoingNodes();
		cout << "Node (";
		for (StmtNum const& n : nums) {
			cout << n << " ";
		}
		cout << ") has " << nodes.size() << " edges pointing to: ";
		for (shared_ptr<ControlFlowNode> const& c : nodes) {
			set<StmtNum> nums = c->GetElements();
			cout << "Node (";
			for (StmtNum const& n : nums) {
				cout << n << " ";
			}
			cout << ")";
		}
		cout << endl;
		for (shared_ptr<ControlFlowNode> const& c : nodes) {
			Display(c, visited);
		}
	}
}